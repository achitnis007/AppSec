#include <check.h>
#include <stdlib.h>
#include "dictionary.h"

#define DICTIONARY "./wordlist.txt" // LONG LIST OF WORDS FOR EXTENSIVE TESTING
#define TESTDICT "./test_worlist.txt" // SHORT LIST OF WORDS FOR CONTROLLED TESTING

// TEST # 1: 
// TEST IF CERTAIN KNOWN WORDS ENDED UP IN CERTAIN BUCKETS TO ENSURE
// hash_function() & load_dictionary() WORKED AS EXPECTED
// Saves the bucket ID generated by hash_function() for a controlled set of dict words
// searches for the bucket ID's from the hashtable populated by load_dictionary()  
// both are expected to match
START_TEST(test_check_load_dictionary)
{
    int first_hash_bucket = -1, second_hash_bucket = -1, third_hash_bucket = -1, test_hash_bucket = -1;
    int first_dict_bucket = -1, second_dict_bucket = -1, third_dict_bucket = -1, test_dict_bucket = -1;
    bool test = false;
    hashmap_t cursor = NULL;
    hashmap_t hashtable[HASH_SIZE];
    ck_assert(load_dictionary(TESTDICT, hashtable));
    // Here we can test if certain words ended up in certain buckets
    // to ensure that our load_dictionary works as intended. I leave
    // this as an exercise.
    // populate bucket ID's basd on hash_function()
    first_hash_bucket = hash_function("first");
    second_hash_bucket = hash_function("second");
    third_hash_bucket = hash_function("third");
    test_hash_bucket = hash_function("test");
    // populate bucket ID's from hashtable created by load_dictionary()
    for (int i=0; i<HASH_SIZE; i++){
	cursor = hashtable[i];    
        while (cursor != NULL){
	    if (!strcmp(cursor->word,"first")) 
	        first_dict_bucket = i;
	    else if (!strcmp(cursor->word,"second")) 
	        second_dict_bucket = i;
	    else if (!strcmp(cursor->word,"third")) 
	        third_dict_bucket = i;
	    else if (!strcmp(cursor->word,"test")) 
	        test_dict_bucket = i;
	    cursor = cursor->next;
	}
    }
    // compare hash bucket ID and dict buckt ID's for each word
    // they should be equal - this proves load_dictionary() worked as expected
    // hashtable index : [552]=first, [636]=second, [539]=third, [448]=test
    test = first_hash_bucket == first_dict_bucket;
    ck_assert_msg(test, "%d == %d", first_hash_bucket, first_dict_bucket);

    test = second_hash_bucket == second_dict_bucket;
    ck_assert_msg(test, "%d == %d", second_hash_bucket, second_dict_bucket);

    test = third_hash_bucket == third_dict_bucket;
    ck_assert_msg(test, "%d == %d", third_hash_bucket, third_dict_bucket);

    test = test_hash_bucket == test_dict_bucket;
    ck_assert_msg(test, "%d == %d", test_hash_bucket, test_dict_bucket);
}
END_TEST

// TEST # 2: 
// TEST A COLLECTION OF VALID & INVALID WORDS
// VALID WORDS SURROUNDED BY PUNCTUATION, VALID WORDS WITH EMBEDDED PUNCTUATION MAKING THEM INVALID 
// UPPERCASE WORDS WITH LOWERCASE EQUIVALENT IN DICT, INVALID WORDS NOT IN DICT
START_TEST(test_check_punctuated_valid_invalid_words)
{
    hashmap_t hashtable[HASH_SIZE];
    load_dictionary(DICTIONARY, hashtable);
    const char* correct_word = "Justice";
    const char* punctuation_word_2 = "pl.ace";
    // Test here: What if a word begins and ends with "?
    const char* punctuation_word_3 = "?Happy?";
    const char* punctuation_word_4 = "?SLAPHAPPY";
    const char* punctuation_word_5 = "?Ethernet's!";
    const char* punctuation_word_6 = "?ethernet!";
    ck_assert(check_word(correct_word, hashtable));
    ck_assert(!check_word(punctuation_word_2, hashtable));
    ck_assert(check_word(punctuation_word_3, hashtable));
    ck_assert(check_word(punctuation_word_4, hashtable));
    ck_assert(check_word(punctuation_word_5, hashtable));
    ck_assert(!check_word(punctuation_word_6, hashtable));
}
END_TEST

// TEST # 3:
// TEST EXPECTED Vs ACTUAL MISSPELLED WORDS 
// TESTS load_dictionary(), check_words(), check_word() & population of misspelled array 
START_TEST(test_check_misspelled_words)
{
    hashmap_t hashtable[HASH_SIZE];
    load_dictionary(DICTIONARY, hashtable);
    char* expected[3];
    expected[0] = "sogn";
    expected[1] = "skyn";
    expected[2] = "betta";
    char *misspelled[MAX_MISSPELLED];
    FILE *fp = fopen("./test1.txt", "r");
    int num_misspelled = check_words(fp, hashtable, misspelled);
    ck_assert(num_misspelled == 3);
    bool test = strlen(misspelled[0]) == strlen(expected[0]);
    int len1 = strlen(misspelled[0]);
    int len2 = strlen(expected[0]);
    ck_assert_msg(test, "%d!=%d", len1, len2);
    ck_assert_msg(strcmp(misspelled[0], expected[0]) == 0);
    ck_assert_msg(strcmp(misspelled[1], expected[1]) == 0);
    ck_assert_msg(strcmp(misspelled[2], expected[2]) == 0);
}
END_TEST

// TEST # 4:
// MARGIN CASE INVALID WORD
START_TEST(test_check_margin_case_invalid_word)
{
    hashmap_t hashtable[HASH_SIZE];
    load_dictionary(DICTIONARY, hashtable);
    char incorrect_word[LENGTH+1];
    for(int i = 0; i < LENGTH+1; i++)
        incorrect_word[i] = 'X';
    incorrect_word[LENGTH] = '\0';
    ck_assert(!check_word(incorrect_word, hashtable));
}
END_TEST

// TEST # 5:
// SHORT WORD VALID INPUT
START_TEST(test_check_short_word_surrounded_by_punct)
{
    hashmap_t hashtable[HASH_SIZE];
    load_dictionary(DICTIONARY, hashtable);
    char correct_word[6];
    correct_word[0] = '"';
    for(int i = 1; i < 4; i++)
        correct_word[i] = 'A';
    correct_word[4] = '"';
    correct_word[5] = '\0';
    ck_assert(check_word(correct_word, hashtable));
}
END_TEST

// TEST # 6:
// SINGLE CHAR WORD VALID INPUT
START_TEST(test_check_single_char_valid_input)
{
    hashmap_t hashtable[HASH_SIZE];
    load_dictionary(DICTIONARY, hashtable);
    char correct_word[2];
    correct_word[0] = 'A';
    correct_word[1] = '\0';
    ck_assert(check_word(correct_word, hashtable));
}
END_TEST

// TEST # 7:
// BUFFER OVERFLOW - VERY LARGE SIZED OBVIOUSLY INVALID WORD (500,000 chars)
START_TEST(test_check_word_buffer_overflow)
{
    hashmap_t hashtable[HASH_SIZE];
    load_dictionary(DICTIONARY, hashtable);
    char incorrect_word[500000];
    for(int i = 0; i < 499999; i++)
        incorrect_word[i] = 'A';
    incorrect_word[499999] = 0;
    ck_assert(!check_word(incorrect_word, hashtable));
}
END_TEST

// DEFINE THE TEST SUITE, ADD UNIT TESTS TO TEST CASE SUITE
Suite *
check_word_suite(void)
{
    Suite * suite;
    TCase * check_word_case;
    suite = suite_create("check_word");
    check_word_case = tcase_create("Core");
    tcase_add_test(check_word_case, test_check_load_dictionary);
    tcase_add_test(check_word_case, test_check_punctuated_valid_invalid_words);
    tcase_add_test(check_word_case, test_check_misspelled_words);
    tcase_add_test(check_word_case, test_check_margin_case_invalid_word);
    tcase_add_test(check_word_case, test_check_short_word_surrounded_by_punct);
    tcase_add_test(check_word_case, test_check_single_char_valid_input);
    tcase_add_test(check_word_case, test_check_word_buffer_overflow);
    suite_add_tcase(suite, check_word_case);

    return suite;
}

// main() TO RUN THE TEST SUITE
int
main(void)
{
    int failed;
    Suite *suite;
    SRunner *runner;
    
    suite = check_word_suite();
    runner = srunner_create(suite);
    srunner_run_all(runner, CK_NORMAL);
    failed = srunner_ntests_failed(runner);
    srunner_free(runner);
    return (failed == 0 ? EXIT_SUCCESS : EXIT_FAILURE);
}
